// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"time"
)

const countRecentListingsByIP = `-- name: CountRecentListingsByIP :one

SELECT COUNT(*)
FROM listings
WHERE
    ip_hash = $1
    AND created_at >= now() - INTERVAL '1 hour'
`

// =====================================================
// BOT / RATE LIMITING HELPERS
// =====================================================
func (q *Queries) CountRecentListingsByIP(ctx context.Context, ipHash []byte) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRecentListingsByIP, ipHash)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVisibleListings = `-- name: CountVisibleListings :one

SELECT COUNT(*)::bigint
FROM listings
WHERE is_hidden = FALSE
`

// =====================================================
// Global counter for DB entries above search
// =====================================================
func (q *Queries) CountVisibleListings(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVisibleListings)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createListing = `-- name: CreateListing :one

INSERT INTO listings (
    body,
    ip_hash
) VALUES (
    $1,
    $2
)
RETURNING
    id,
    body,
    is_hidden,
    created_at
`

type CreateListingParams struct {
	Body   string
	IpHash []byte
}

type CreateListingRow struct {
	ID        int64
	Body      string
	IsHidden  bool
	CreatedAt time.Time
}

// =====================================================
// LISTINGS
// =====================================================
func (q *Queries) CreateListing(ctx context.Context, arg CreateListingParams) (CreateListingRow, error) {
	row := q.db.QueryRowContext(ctx, createListing, arg.Body, arg.IpHash)
	var i CreateListingRow
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.IsHidden,
		&i.CreatedAt,
	)
	return i, err
}

const searchListingsAfterCursor = `-- name: SearchListingsAfterCursor :many
SELECT
    id,
    body,
    created_at
FROM listings
WHERE
    is_hidden = FALSE
    AND (
        $1::text IS NULL
        OR body_tsv @@ plainto_tsquery('simple', $1)
    )
    AND (
        created_at < $2
        OR (created_at = $2 AND id < $3)
    )
ORDER BY created_at DESC, id DESC
LIMIT $4
`

type SearchListingsAfterCursorParams struct {
	Column1   string
	CreatedAt time.Time
	ID        int64
	Limit     int32
}

type SearchListingsAfterCursorRow struct {
	ID        int64
	Body      string
	CreatedAt time.Time
}

func (q *Queries) SearchListingsAfterCursor(ctx context.Context, arg SearchListingsAfterCursorParams) ([]SearchListingsAfterCursorRow, error) {
	rows, err := q.db.QueryContext(ctx, searchListingsAfterCursor,
		arg.Column1,
		arg.CreatedAt,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchListingsAfterCursorRow{}
	for rows.Next() {
		var i SearchListingsAfterCursorRow
		if err := rows.Scan(&i.ID, &i.Body, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchListingsFirstPage = `-- name: SearchListingsFirstPage :many

SELECT
    id,
    body,
    created_at
FROM listings
WHERE
    is_hidden = FALSE
    AND (
        $1::text IS NULL
        OR body_tsv @@ plainto_tsquery('simple', $1)
    )
ORDER BY created_at DESC, id DESC
LIMIT $2
`

type SearchListingsFirstPageParams struct {
	Column1 string
	Limit   int32
}

type SearchListingsFirstPageRow struct {
	ID        int64
	Body      string
	CreatedAt time.Time
}

// =====================================================
// LISTINGS SEARCH (KEYSET PAGINATION)
// =====================================================
func (q *Queries) SearchListingsFirstPage(ctx context.Context, arg SearchListingsFirstPageParams) ([]SearchListingsFirstPageRow, error) {
	rows, err := q.db.QueryContext(ctx, searchListingsFirstPage, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchListingsFirstPageRow{}
	for rows.Next() {
		var i SearchListingsFirstPageRow
		if err := rows.Scan(&i.ID, &i.Body, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const touchListingsByIP = `-- name: TouchListingsByIP :exec
UPDATE listings
SET ip_hash = ip_hash
WHERE ip_hash = $1
`

func (q *Queries) TouchListingsByIP(ctx context.Context, ipHash []byte) error {
	_, err := q.db.ExecContext(ctx, touchListingsByIP, ipHash)
	return err
}
