import { useCallback, useEffect, useRef, useState } from "react";
import { useForm, useWatch } from "react-hook-form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";

// ==================================================
// Types
// ==================================================

type Mode = "idle" | "search" | "searching" | "posting" | "error";

interface Listing {
  id: number;
  body: string;
  created_at: string;
}

interface SearchResponse {
  items: Listing[];
  next_cursor?: string;
}

// ==================================================
// API helpers
// ==================================================

async function searchAPI(
  q: string,
  limit: number,
  cursor: string | null,
  signal: AbortSignal
): Promise<SearchResponse> {
  const params = new URLSearchParams();
  params.set("q", q);
  params.set("limit", String(limit));
  if (cursor) params.set("cursor", cursor);

  const res = await fetch(`/api/listings/search?${params.toString()}`, {
    signal,
  });

  if (!res.ok) throw new Error("search failed");
  return res.json();
}

async function postAPI(text: string, signal: AbortSignal): Promise<Listing> {
  const res = await fetch("/api/listings/create", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text }),
    signal,
  });

  if (!res.ok) throw new Error("post failed");
  return res.json();
}

// ==================================================
// Components (unchanged)
// ==================================================

function ControlLine(props: {
  query: string;
  disabled: boolean;
  onQueryChange(q: string): void;
  onSearch(): void;
  onPostToggle(): void;
}) {
  return (
    <div className="mt-12 w-full flex justify-center">
      <div className="flex flex-col md:flex-row items-center gap-3 w-[90vw] md:w-auto">
        <Input
          placeholder="Search…"
          className="md:w-[20vw] w-[90vw]"
          value={props.query}
          disabled={props.disabled}
          onChange={(e) => props.onQueryChange(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") props.onSearch();
          }}
        />
        <Button
          className="md:w-[5vw] w-[45vw]"
          disabled={props.disabled}
          onClick={props.onPostToggle}
        >
          Post
        </Button>
      </div>
    </div>
  );
}

function SearchResults(props: {
  items: Listing[];
  loading: boolean;
  hasMore: boolean;
  onLoadMore(): void;
}) {
  const loaderRef = useRef<HTMLDivElement | null>(null);

  const { items, loading, hasMore, onLoadMore } = props;

  useEffect(() => {
    if (!loaderRef.current) return;

    const obs = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting && hasMore && !loading) {
        onLoadMore();
      }
    });

    obs.observe(loaderRef.current);
    return () => obs.disconnect();
  }, [hasMore, loading, onLoadMore]);

  return (
    <div className="mt-8 w-full flex flex-col items-center gap-3">
      {items.map((l) => (
        <Card key={l.id} className="w-[90vw] md:w-[40vw] bg-zinc-900">
          <CardContent className="p-3 whitespace-pre-wrap">
            {l.body}
          </CardContent>
        </Card>
      ))}
      {hasMore && <div ref={loaderRef} className="h-10" />}
    </div>
  );
}

function PostForm(props: { onSubmit(text: string): void; disabled: boolean }) {
  const form = useForm<{ text: string }>({ defaultValues: { text: "" } });
  const len = useWatch({ control: form.control, name: "text" })?.length ?? 0;

  return (
    <Card className="mt-6 w-[90vw] md:w-[40vw] bg-zinc-900">
      <CardContent className="p-4">
        <form
          onSubmit={form.handleSubmit((d) => props.onSubmit(d.text))}
          className="space-y-2"
        >
          <textarea
            {...form.register("text", { maxLength: 1000 })}
            className="w-full h-32 bg-zinc-800 rounded-md p-2"
            placeholder="Write your post…"
            disabled={props.disabled}
          />
          <div className="flex justify-between text-xs text-zinc-400">
            <span>{1000 - len} chars left</span>
            <Button type="submit" disabled={props.disabled || len === 0}>
              Submit
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}

// ==================================================
// App (fixed)
// ==================================================

export default function App() {
  const [mode, setMode] = useState<Mode>("idle");
  const [query, setQuery] = useState("");

  const [items, setItems] = useState<Listing[]>([]);
  const [cursor, setCursor] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(false);

  const searchAbort = useRef<AbortController | null>(null);
  const postAbort = useRef<AbortController | null>(null);

  const PAGE_SIZE = 30;

  const isSearching = mode === "searching";

  // -------------------------------
  // Search
  // -------------------------------

  const startSearch = useCallback(async () => {
    searchAbort.current?.abort();

    // CLEAR when query is empty
    if (!query.trim()) {
      setItems([]);
      setCursor(null);
      setHasMore(false);
      setMode("idle");
      return;
    }

    searchAbort.current = new AbortController();

    setMode("searching");
    setItems([]);
    setCursor(null);
    setHasMore(false);

    try {
      const res = await searchAPI(
        query,
        PAGE_SIZE,
        null,
        searchAbort.current.signal
      );

      setItems(res.items);
      setCursor(res.next_cursor ?? null);
      setHasMore(Boolean(res.next_cursor));
      setMode("search");
    } catch {
      setMode("error");
    }
  }, [query]);

  const loadMore = useCallback(async () => {
    if (mode !== "search" || !cursor) return;

    searchAbort.current = new AbortController();
    setMode("searching");

    try {
      const res = await searchAPI(
        query,
        PAGE_SIZE,
        cursor,
        searchAbort.current.signal
      );

      setItems((prev) => [...prev, ...res.items]);
      setCursor(res.next_cursor ?? null);
      setHasMore(Boolean(res.next_cursor));
      setMode("search");
    } catch {
      setMode("error");
    }
  }, [mode, cursor, query]);

  // -------------------------------
  // Post
  // -------------------------------

  const togglePost = () => {
    searchAbort.current?.abort();

    setMode("posting");
    setQuery("");
    setItems([]);
    setCursor(null);
    setHasMore(false);
  };

  const submitPost = async (text: string) => {
    postAbort.current?.abort();
    postAbort.current = new AbortController();

    try {
      await postAPI(text, postAbort.current.signal);
      setMode("idle");
    } catch {
      setMode("error");
    }
  };

  return (
    <div className="min-h-screen bg-zinc-950 text-zinc-100 flex flex-col items-center">
      <ControlLine
        query={query}
        disabled={mode === "searching" || mode === "posting"}
        onQueryChange={setQuery}
        onSearch={startSearch}
        onPostToggle={togglePost}
      />

      {mode === "searching" && (
        <div className="mt-4 text-sm text-zinc-400">search in progress…</div>
      )}
      {mode === "posting" && (
        <div className="mt-4 text-sm text-zinc-400">saving…</div>
      )}
      {mode === "error" && (
        <div className="mt-4 text-sm text-red-400">something went wrong</div>
      )}

      {mode === "posting" && (
        <PostForm onSubmit={submitPost} disabled={mode !== "posting"} />
      )}

      {mode === "search" && (
        <SearchResults
          items={items}
          loading={isSearching}
          hasMore={hasMore}
          onLoadMore={loadMore}
        />
      )}
    </div>
  );
}
